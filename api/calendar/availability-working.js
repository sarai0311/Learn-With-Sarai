const { google } = require('googleapis');\n\n// Environment variables\nconst SERVICE_ACCOUNT_EMAIL = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;\nconst PRIVATE_KEY = process.env.GOOGLE_PRIVATE_KEY;\nconst PRIMARY_CALENDAR_ID = process.env.GOOGLE_CALENDAR_ID || 'sarai.syav@gmail.com';\n\n// Time slots (Atlantic/Canary time)\nconst TIME_SLOTS = ['13:00', '14:00', '15:00', '16:00', '17:00', '18:00', '19:00', '20:00', '21:00', '22:00'];\n\n// Create Google Calendar client\nconst createCalendarClient = async () => {\n  try {\n    if (!SERVICE_ACCOUNT_EMAIL || !PRIVATE_KEY) {\n      console.error('Google Calendar credentials not configured');\n      return null;\n    }\n\n    const credentials = {\n      type: 'service_account',\n      client_email: SERVICE_ACCOUNT_EMAIL,\n      private_key: PRIVATE_KEY.replace(/\\\\n/g, '\\n'),\n    };\n\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/calendar']\n    });\n    \n    const authClient = await auth.getClient();\n    return google.calendar({ version: 'v3', auth: authClient });\n  } catch (error) {\n    console.error('Error creating Google Calendar client:', error);\n    return null;\n  }\n};\n\n// Simple date functions (replacing date-fns)\nconst addDays = (date, days) => {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n};\n\nconst formatDate = (date) => {\n  return date.toISOString().split('T')[0];\n};\n\nconst isWeekend = (date) => {\n  const day = date.getDay();\n  return day === 0 || day === 6; // Sunday or Saturday\n};\n\nmodule.exports = async function handler(req, res) {\n  // Set CORS headers\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n  if (req.method === 'OPTIONS') {\n    res.status(200).end();\n    return;\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Input validation\n    const requestBody = req.body || {};\n    const days = Math.min(Math.max(parseInt(requestBody.days) || 14, 1), 60);\n    const timezone = requestBody.timezone || 'Atlantic/Canary';\n    \n    console.log('üöÄ Generating availability for', days, 'days');\n    \n    // Get calendar client\n    const calendar = await createCalendarClient();\n    if (!calendar) {\n      return res.status(500).json({ error: 'Failed to create calendar client' });\n    }\n\n    // Fetch busy times using freebusy query\n    const startDate = new Date();\n    const endDate = addDays(startDate, days);\n    \n    console.log('üîç Checking busy times from', startDate.toISOString(), 'to', endDate.toISOString());\n    \n    const response = await calendar.freebusy.query({\n      requestBody: {\n        timeMin: startDate.toISOString(),\n        timeMax: endDate.toISOString(),\n        timeZone: timezone,\n        items: [{ id: PRIMARY_CALENDAR_ID }]\n      }\n    });\n\n    const busyTimes = response.data.calendars?.[PRIMARY_CALENDAR_ID]?.busy || [];\n    console.log('üìã Found', busyTimes.length, 'busy periods');\n    \n    // Generate availability\n    const availability = {};\n    \n    for (let i = 0; i < days; i++) {\n      const date = addDays(startDate, i);\n      const dateKey = formatDate(date);\n      \n      // Skip weekends\n      if (isWeekend(date)) {\n        availability[dateKey] = {\n          date: dateKey,\n          slots: TIME_SLOTS.map(time => ({\n            time,\n            available: false,\n            reason: 'weekend'\n          }))\n        };\n        continue;\n      }\n      \n      // Check each time slot\n      const slots = TIME_SLOTS.map(time => {\n        const slotDateTime = new Date(`${dateKey}T${time}:00`);\n        \n        // Skip past times\n        if (slotDateTime < new Date()) {\n          return { \n            time, \n            available: false, \n            reason: 'past' \n          };\n        }\n        \n        // Check if slot conflicts with busy times\n        const slotEnd = new Date(slotDateTime.getTime() + 60 * 60 * 1000); // 1 hour later\n        \n        const isBusy = busyTimes.some(busy => {\n          const busyStart = new Date(busy.start);\n          const busyEnd = new Date(busy.end);\n          return slotDateTime < busyEnd && slotEnd > busyStart;\n        });\n        \n        return { \n          time, \n          available: !isBusy,\n          reason: isBusy ? 'busy' : undefined\n        };\n      });\n\n      availability[dateKey] = {\n        date: dateKey,\n        slots\n      };\n    }\n\n    console.log('‚úÖ Generated availability for', Object.keys(availability).length, 'days');\n    \n    res.json({ \n      availability,\n      timezone,\n      generatedAt: new Date().toISOString()\n    });\n    \n  } catch (error) {\n    console.error('‚ùå Error in availability function:', error);\n    res.status(500).json({ \n      error: 'Internal server error',\n      message: error.message\n    });\n  }\n};